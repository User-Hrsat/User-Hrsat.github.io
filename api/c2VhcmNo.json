[{"title":"SQL要点","date":"2022-05-10T11:18:00.000Z","date_formatted":{"ll":"2022年5月10日","L":"2022/05/10","MM-DD":"05-10"},"updated":"2022-05-14T01:54:00.000Z","content":"SQL 要点\n表的创建\n\n常用数据类型\n\n串(字符序列？)\n\n\nCHAR : 1~255 定长字符串；长度在创建时指定，未指定则默认为 1\nVARCHAR : 可变长度；最多不超过 255，创建时可指定最大长度\n\n\n数值\n\n\nTINYINT : 整数值；-128~127，UNSIGNED 为 0~255\nINT : 整数值；-2147483648～2147483647，UNSIGNED 为 0～4294967295\nFLOAT : 单精度浮点数\nDOUBLE : 双精度浮点数\nDECIMAL(或DEC) : 精度可变的浮点数\nBOOLEAN : 布尔值\n\n\n日期和时间\n\n\nDATE : 1000-01-01～9999-12-31，格式 YYYY-MM-DD\nTIME : 格式 HH:MM:SS\nDATETIME : DATE 与 TIME 的组合\nTIMESTAMP : 功能与 DATETIME 相同(但范围较小)\nYEAR : 用2位数字表示，范围是 70(1970)～69(2069 )，用4位数字表示，范围是 1901～2155\n\n\n二进制(存文件什么的)\n\n\nBLOB : 最大长度 64KB\nTINYBLOB : 最大长度 255字节\nMEDIUMBLOB : 最大长度 16MB\nLONGBLOB : 最大长度 4GB\n\n列的约束\n\nAUTO_INCREMENT : 设置字段自增，比如 ID 自增\nDEFAULT : 指定字段默认值\nPRIMARY KEY : 主键,不为空且唯一\nFOREIGN KEY : 外键，包含其他表的主键\n\n引擎类型\n\nENGINE\n\n\nInnoDB\nMEMORY\nMyISAM\n\n表的更新\n\n字段操作\nALTER TABLE\n\n\n添加字段\nALTER TABLE &lt;表名&gt; ADD &lt;列名&gt; &lt;类型&gt; [约束]\n\n\n字段更改\n\n\n\nCHANGE ::=\nALTER TABLE &lt;表名&gt; CHANGE &lt;旧列名&gt; &lt;新列名&gt; &lt;类型&gt; [约束] !!: 改列名\n| ALTER TABLE &lt;表名&gt; CHANGE &lt;列名&gt; &lt;列名&gt; &lt;类型&gt; [约束] !!: 改属性\nMODIFY ::=\nALTER TABLE &lt;表名&gt; MODEIFY &lt;列名&gt; &lt;类型&gt; [约束]\n!!: 不能更改列名\n\n\n\n字段删除\nDROP COLUMN ::= ALTER TABLE &lt;表名&gt; DROP COLUMN &lt;列名&gt;\n\n\n重命名表\nRENAME TABLE ::= RENAME TABLE &lt;旧表名&gt; &lt;新表名&gt;...\n\n\n数据操作\n\n\n更新数据\nUPDATE &lt;表名&gt; SET &lt;列名&gt; = &lt;数据&gt;... [WHERE &lt;条件&gt;]\n!!: 没有条件就可以更改字段的全部值\n\n\n删除数据\nDELETE FROM &lt;表名&gt; [WHERE &lt;条件&gt;]\n!!: 没有条件则可以清空表中数据\n\n\n表的查询\n\n过滤\n\n\nIN\nIN (数据, 数据)\n\n\nLIKE\nLIKE &lt;通配符&gt;\n\n\n\n% : 表示任意字符出现任意次数\n_ : 表示任意字符,一个 _ 只匹配一个字符\n指定文本\n\n分组过滤\nHAVING 过滤 GROUP BY 后的数据，功能与 WHERE 类似\n\nWHERE : 行过滤\nHAVING : 分组过滤\n\n数据处理函数\n\n常用文本处理函数\n\n\nLeft() : 返回传左边的字符\nLength() : 返回串的长度\nLoacte() : 找出串的一个子串\nLower() : 将串转换为小写\nLTrim() : 去掉串左边的空格\nRight() : 返回串右边的字符\nRTrim() : 去掉串右边的空格\nSoundex() : 返回串的SOUNDEX值\nSubString() : 返回子串的字符\nUpper() : 将串转换为大写\n\n\n常用日期和时间处理函数\n\n\nAddDate() : 增加一个日期(天、周等)\nAddTime() : 增加一个时间(时、分等)\nCurDate() : 返回当前日期\nCurTime() : 返回当前时间\nDate() : 返回日期时间的日期部分\nDateDiff() : 计算两个日期之差\nDate_Add() : 高度灵活的日期运算函数\nDate_Format() : 返回一个格式化的日期或时间串\nDay() : 返回一个日期的天数部分\nDayOfWeek() : 对于一个日期，返回对应的星期几\nHour() : 返回一个时间的小时部分\nMinute() : 返回一个时间的分钟部分\nMonth() : 返回一个日期的月份部分\nNow() : 返回当前日期和时间\nSecond() : 返回一个时间的秒部分\nTime() : 返回一个日期时间的时间部分\nYear() : 返回一个日期的年份部分\n\n\n常用数值处理函数\n\n\nAbs() : 返回一个数的绝对值\nCos() : 返回一个角度的余弦\nExp() : 返回一个数的指数值\nMod() : 返回除操作的余数\nPi() : 返回圆周率\nRand() : 返回一个随机数\nSin() : 返回一个角度的正弦\nSqrt() : 返回一个数的平方根\nTan() : 返回一个角度的正切\n\n聚集函数 | 聚合函数\n聚合函数用于 SELECT 子句\nSELECT &lt;FUNC(列名)&gt;...\nCOUNT() : 总行数\nMAX() : 最大值\nMIN() : 最小值\nSUM() : 求合\nAVG() : 平均值\n排序\nORDER BY &lt;列名&gt; [DESC|ASC]\n!!: 默认为升序 ASC\n限制结果\nLIMIT &lt;ROW_COUNT&gt; [OFFSET OF_COUNT]\n限制输出的个数和偏移量\n给定偏移量的情况下会先偏移\n简单联结\n\n内部连接 INNER JOIN | 等值联结 (? 等价还是包含\n\n\n\n内联结\nSELECT &lt;列名&gt; FROM &lt;表名&gt; INNER JOIN &lt;表名&gt; ON &lt;条件&gt;\n\n\n等值联结\nSELECT &lt;列名&gt; FROM &lt;表名&gt;, &lt;表名&gt; [WHERE &lt;条件&gt;]\n&lt;条件&gt; ::= &lt;表名&gt;.&lt;列名&gt; = &lt;表名&gt;.&lt;列名&gt;...\n\n\n\n笛卡儿积(cartesian product) (又称交叉联结 CROSS JOIN\n由没有联结条件的表关系返回的结果为笛卡儿积。\n检索出的行的数目将是第一个表中的行数乘以第二个表中的行数。\n\n\n高级联结\n\n\n表别名\nSELECT &lt;列名&gt; FROM &lt;表名&gt; AS &lt;别名&gt; [WHERE &lt;条件&gt;]\n\n\n自联结 SELF-JOIN\nSELECT &lt;别名&gt;.&lt;列名&gt;... FROM &lt;表名&gt; AS &lt;别名&gt;, &lt;表名&gt; AS &lt;别名&gt;... WHERE &lt;别名&gt;.&lt;列名&gt; = &lt;别名&gt;.&lt;列名&gt; [AND &lt;别名&gt;.&lt;列名&gt;...]\n使用表别名而不是子查询\nWHERE 首先会联结表，然后按照条件过滤并返回数据\n\n\n自然联结 NATURAL JOIN\n\n\n1234567    无论何时对表进行联结，应该至少有一个列出现在不止一个表中（被联结的列）。标准的联结（前一章中介绍的内部联结）返回所有数据，甚至相同的列多次出现。自然联结排除多次出现，使每个列只返回一次。    怎样完成这项工作呢？答案是，系统不完成这项工作，由你自己完成它。自然联结是这样一种联结，其中你只能选择那些唯一的列。这一般是通过对表使用通配符（SELECT *），对所有其他表的列使用明确的子集来完成的。下面举一个(两个)例子:\n\n123456SELECT C.*, O.order_num, O.order_date,OI.prod_id, OI.quantity, OI.item_priceFROM Customers AS C, Orders AS O, OrderItems AS OIWHERE C.cust_id = O.cust_idAND OI.order_num = O.order_numAND prod_id = &#x27;RGAN01&#x27;;\n1234    在这个例子中，通配符只对第一个表使用。所有其他列明确列出，所以没有重复的列被检索出来。    事实上，迄今为止我们建立的每个内部联结都是自然联结，很可能我们永远都不会用到不是自然联结的内部联结。\n\n外部连接 OUTER JOIN\n\n\n将一个表中的行与另一个表中的行相关联，但有时候需要包含没有关联行的那些行\n\n\n\n左外联结\nSELECT &lt;列名&gt;... FROM &lt;表名&gt; LEFT [OUTER] JOIN &lt;表名&gt; ON &lt;条件&gt;\n\n\n右外联结\nSELECT &lt;列名&gt;... FROM &lt;表名&gt; RIGHT [OUTER] JOIN &lt;表名&gt; ON &lt;条件&gt;\n\n外部联结的类型\n\n 1234    存在两种基本的外部联结形式：左外部联结和右外部联结。它们之间的唯一差别是所关联的表的顺序不同。换句话说，左外部联结可通过颠倒FROM或WHERE子句中表的顺序转换为右外部联结。因此，两种类型的外部联结可互换使用，而究竟使用哪一种纯粹是根据方便而定。\n\n\n组合查询\n\n将多条查询语句的结果合并为结果集\n\n\nUNION\n&lt;查询&gt; UNION &lt;查询&gt; [WHERE|ORDER BY...]\n将会去除重复行\nUNION ALL\n&lt;查询&gt; UNION ALL [WHERE|ORDER BY...]\n使用 UNION ALL 不会去除重复的行\n\n窗口函数\n\n也称 OLAP 函数，OnLine Analytical Processing 的简称\n\n&lt;窗口函数&gt; OVER ([PARTITION BY &lt;列名&gt;...] ORDER BY &lt;列名&gt; [ASC|DESC]...)\n\n窗口函数\n\n\n聚合函数\nSUM AVG COUNT MAX MIN\n专用函数\nRANK DENSE RANK ROW_NUMBER\n\nRANK\n计算排序时，如果存在相同位次的记录，则会跳过之后的位次。\n例）有 3 条记录排在第 1 位时：1 位、1 位、1 位、4 位……\nDENSE_RANK\n同样是计算排序，即使存在相同位次的记录，也不会跳过之后的位次。\n例）有 3 条记录排在第 1 位时：1 位、1 位、1 位、2 位……\nROW_NUMBER\n赋予唯一的连续位次。\n例）有 3 条记录排在第 1 位时：1 位、2 位、3 位、4 位……\n\n\n\n\nPARTTION BY\n\n\n非必要\n无需指定 PARTITION BY 窗口函数也照常工作\n分组汇总行数不变\nGROUP BY 一个类别只有一行\nPARTITION BY 不会减少原表的行数\n\n\n两个 ORDER BY\nOVER 中的 ORDER BY 与 WHERE 子句中的 ORDER BY 功能完全不相同\n按需使用\n\n文本搜索\n\n使用正则进行搜索\nWHERE &lt;列名&gt; REGEXP &quot;正则表达式&quot;\n全文搜索\nWHERE Match(列名) Against(表达式)\n\n全文搜索支持\n在建表时使用 FULLTEXT(列名)\n扩展查询\nWHERE Match(列名) Against(表达式 WITH QUERY EXPANSION)\n用于查找可能的相关结果\n\n123456    首先，进行一个基本的全文本搜索，找出与搜索条件匹配的所有行；    其次，MySQL检查这些匹配行并选择所有有用的词（我们将会简要地解释MySQL如何断定什么有用，什么无用）。    再其次，MySQL再次进行全文本搜索，这次不仅使用原来的条件，而且还使用所有有用的词。\n\n布尔文本搜索\nWHERE Match(列名) Against(表达式 IN BOOLEAN MODE)\n\n\n全文本布尔操作符\n\n\n+ : 包含，词必须存在\n- : 排除，词必须不出现\n&gt; : 包含，而且增加等级值\n&lt; : 包含，且减少等级值\n() : 把词组成子表达式（允许这些子表达式作为一个组被包含、排除、排列等）\n~ : 取消一个词的排序值\n* : 词尾的通配符\n&quot;&quot; : 定义一个短语（与单个词的列表不一样，它匹配整个短语以便包含或排除这个短语）\n\n视图\n游标\n触发器\n事务管理\n其他\n\n插入检索出的数据\nINSERT INTO &lt;表名(列名...)&gt; SELECT &lt;列名&gt;... FROM &lt;表名&gt;...\n将一个表中查出来的数据插入另一个表中\nBNF范式 参考\n\n::= 定义\n&lt;&gt; 必要\n[] 可选\n| 或\n... 可以出现多次或省略内容\n\n","plink":"https://user-hrsat.github.io/2022/05/10/SQL要点/"},{"title":"浅拷贝与深拷贝","date":"2020-11-22T10:25:51.000Z","date_formatted":{"ll":"2020年11月22日","L":"2020/11/22","MM-DD":"11-22"},"updated":"2020-11-22T10:25:51.000Z","content":"浅拷贝与深拷贝\n引导\n\n如下两段代码:\n\n\n其一\n\n123456789101112131415dic0 = &#123;&#x27;init&#x27; : [[], []]&#125;dic1 = &#123;&#x27;init&#x27; : &#123;&#x27;sender&#x27; : []&#125;&#125;group = [0, 1, 2]for i in group:    if i not in dic0:        dic0[i] = dic0[&#x27;init&#x27;]    if i not in dic1:        dic1[i] = dic1[&#x27;init&#x27;]dic0[0][0].append(&#x27;sender&#x27;)dic0[0][1].append(&#x27;message&#x27;)dic1[0][&#x27;sender&#x27;].append(&#x27;message&#x27;)print(f&#x27;&#123;dic0&#125;\\n&#123;dic1&#125;&#x27;)\n\n其二\n\n123456789101112131415dic0 = &#123;&#x27;init&#x27; : [[], []]&#125;dic1 = &#123;&#x27;init&#x27; : &#123;&#x27;sender&#x27; : []&#125;&#125;group = [0, 1, 2]for i in group:    if i not in dic0:        dic0[i] = [[], []]    if i not in dic1:        dic1[i] = &#123;&#x27;sender&#x27; : []&#125;dic0[0][0].append(&#x27;sender&#x27;)dic0[0][1].append(&#x27;message&#x27;)dic1[0][&#x27;sender&#x27;].append(&#x27;message&#x27;)print(f&#x27;&#123;dic0&#125;\\n&#123;dic1&#125;&#x27;)\n\n输出如下:\n\n123456其一&#123;&#x27;init&#x27;: [[&#x27;sender&#x27;], [&#x27;message&#x27;]], 0: [[&#x27;sender&#x27;], [&#x27;message&#x27;]], 1: [[&#x27;sender&#x27;], [&#x27;message&#x27;]], 2: [[&#x27;sender&#x27;], [&#x27;message&#x27;]]&#125;&#123;&#x27;init&#x27;: &#123;&#x27;sender&#x27;: [&#x27;message&#x27;]&#125;, 0: &#123;&#x27;sender&#x27;: [&#x27;message&#x27;]&#125;, 1: &#123;&#x27;sender&#x27;: [&#x27;message&#x27;]&#125;, 2: &#123;&#x27;sender&#x27;: [&#x27;message&#x27;]&#125;&#125;其二&#123;&#x27;init&#x27;: [[], []], 0: [[&#x27;sender&#x27;], [&#x27;message&#x27;]], 1: [[], []], 2: [[], []]&#125;&#123;&#x27;init&#x27;: &#123;&#x27;sender&#x27;: []&#125;, 0: &#123;&#x27;sender&#x27;: [&#x27;message&#x27;]&#125;, 1: &#123;&#x27;sender&#x27;: []&#125;, 2: &#123;&#x27;sender&#x27;: []&#125;&#125;\n\n只有其二得到了预想中的效果\n为什么？\n其一的代码从逻辑上看起来并没有问题啊！\n为什么得不到预期的结果？\n\n为什么？\n\n参考：\n\n浅拷贝与深拷贝 - 浪里行舟的文章 - 知乎：https://zhuanlan.zhihu.com/p/56741046\nPython中的赋值(复制)、浅拷贝与深拷贝 - 晚来天御雪的文章 - 知乎：https://zhuanlan.zhihu.com/p/54011712\n5张图彻底理解Python中的浅拷贝与深拷贝 - 张小鸡的文章 - 知乎：https://zhuanlan.zhihu.com/p/57893374\n","plink":"https://user-hrsat.github.io/2020/11/22/deepcopy/"},{"title":"Django","date":"2020-09-08T13:36:30.000Z","date_formatted":{"ll":"2020年9月8日","L":"2020/09/08","MM-DD":"09-08"},"updated":"2020-09-08T13:36:30.000Z","content":"Django\n\n","plink":"https://user-hrsat.github.io/2020/09/08/Django/"},{"title":"Python小技巧","date":"2020-06-29T09:18:19.000Z","date_formatted":{"ll":"2020年6月29日","L":"2020/06/29","MM-DD":"06-29"},"updated":"2020-06-29T09:18:19.000Z","content":"Python小技巧\n其一\n\n可以字典的方式实现switch case,比switch case更简洁\n\n\n拒绝多层if从菜鸡做起\n\n123456789101112131415161718def func0():    print(&quot;正在调用func0()!&quot;)def func1():    print(&quot;正在调用func1()!&quot;)def func2():    print(&quot;正在调用func2()!&quot;)dicswi = &#123;    &#x27;key0&#x27; : func0,    &#x27;key1&#x27; : func1,    &#x27;key2&#x27; : func2&#125;dicswi[&#x27;key0&#x27;]()dicswi[&#x27;key1&#x27;]()dicswi[&#x27;key2&#x27;]()\n......\n","plink":"https://user-hrsat.github.io/2020/06/29/Python小技巧/"},{"title":"函数装饰器与闭包","date":"2020-06-25T03:58:04.000Z","date_formatted":{"ll":"2020年6月25日","L":"2020/06/25","MM-DD":"06-25"},"updated":"2020-06-25T03:58:04.000Z","content":"函数装饰器与闭包\n原理\n装饰器的定义\n12345    装饰器是可调用的对象，其参数是另一个函数(被装饰的函数)。装饰器可能处理被装饰的函数，然后把它返回，或者将其替换成另一个函数或可调用对象。    函数装饰器用于在源码中“标记”函数，以某种方式增强函数的行为。    想要自己实现装饰器，就需要了解闭包，也需要知道nonlocal。\n\n装饰器只是语法糖。有时会很方便，比如元编程\n\n装饰器的特性\n\n能把被装饰的函数替换成其他函数\n装饰器在加载模块时立即执行\n\n实践\n123456789101112131415161718192021222324252627registry = []def register(func):    print(&#x27;running register(%s)&#x27; %func) # 打印被装饰的函数    registry.append(func)    return func@register    ➊                          # 第一次执行(第一行)def f1():    print(&#x27;running f1()&#x27;)@register    ➋                          # 第二次执行(第二行)def f2():    print(&#x27;running f2()&#x27;)def f3():    print(&#x27;running f3()&#x27;)def main():  ➌    print(&#x27;running main()&#x27;)             # 第三行    print(&#x27;registry -&gt;&#x27;, registry)   ➍  # 第四行    f1()     ➎                          # 第五行    f2()     ➏                          # 第六行    f3()     ➐                          # 第七行if __name__==&#x27;__main__&#x27;:    main()   ➌\n\n对应输出如下:\n\n1234567running register(&lt;function f1 at 0x7fc2be212c10&gt;)running register(&lt;function f2 at 0x7fc2be212ca0&gt;)running main()registry -&gt; [&lt;function f1 at 0x7fc2be212c10&gt;, &lt;function f2 at 0x7fc2be212ca0&gt;]running f1()running f2()running f3()\n\n玄学MD显示不出来，那就贴张图吧\n\n\n➊➋:两次使用装饰器依次执行，被装饰函数作为参数被调用\n➌:main()被执行\n➍:装饰器作用的二次证明\n➎➏➐:无装饰器正常执行\n后续继续补充\n","plink":"https://user-hrsat.github.io/2020/06/25/函数装饰器与闭包/"},{"title":"Python的数据模型","date":"2020-06-19T13:42:22.000Z","date_formatted":{"ll":"2020年6月19日","L":"2020/06/19","MM-DD":"06-19"},"updated":"2023-03-25T08:50:14.360Z","content":"Python的数据模型\n\n对于菜鸡的新概念\n\n\nnamedtuple-定义具有少数属性但没有方法的对象\n\n\n抽象概念，一直不理解\n\n\n魔术方法“getitem”，特殊方法、双下方法(dunder method)\n\n\n之前OOP学过，一直不理解；学这个有什么用？代码更具Pythonic、扩充Python功能\n\n","plink":"https://user-hrsat.github.io/2020/06/19/Python数据模型/"},{"title":"JavaWeb","date":"2020-05-18T07:36:59.000Z","date_formatted":{"ll":"2020年5月18日","L":"2020/05/18","MM-DD":"05-18"},"updated":"2023-03-25T08:50:14.360Z","content":"JavaWeb网课随堂笔记\n\n先记，再整理\n\n","plink":"https://user-hrsat.github.io/2020/05/18/JavaWeb/"},{"title":"phpMyAdmin","date":"2020-03-07T01:44:19.000Z","date_formatted":{"ll":"2020年3月7日","L":"2020/03/07","MM-DD":"03-07"},"updated":"2023-03-25T08:50:14.371Z","content":"phpMyAdmin\n\nphpMyAdmin配置的琐碎细节，介于ArchWiki对于本菜鸡而言具有一定迷惑性\n\n简单说明:\n12345    phpMyAdmin 是 MySQL 的一款第三方 WEB 客户端。由 Server 机提供(可能不限于此种形式)服务，需要手动设置 http/https 服务(这就触及我的知识盲区了)    环境：Manjaro(Arch)    (特声明默认PHP版本为7)\n服务配置\nArchWik 给提供了很多方案(确实让我等菜鸡有点迷)，我选了这一套：\n1apache + php-fpm\n文件细则\n\n/etc/php/php.ini 取消这两行注释：\n\n\n视实际情况而定\n\n12extension=pdo_mysql.soextension=mysqli.so\nApache配置\n\n创建 Apache 配置文件：\n\n\n如果只想从本地访问 phpMyAdmin，将 Require all granted 改为 Require local\n\n123456789/etc/httpd/conf/extra/phpmyadmin.conf----------------------------------------------------------------Alias /phpmyadmin &quot;/usr/share/webapps/phpMyAdmin&quot;&lt;Directory &quot;/usr/share/webapps/phpMyAdmin&quot;&gt;    DirectoryIndex index.php    AllowOverride All    Options FollowSymlinks    Require all granted&lt;/Directory&gt;\n\n在 /etc/httpd/conf/httpd.conf 加入配置：\n\n12# phpMyAdmin configurationInclude conf/extra/phpmyadmin.conf\nApache 使用 PHP 的方式也有很多种，我选择 php-fpm\n\n启用代理模块\n\n1234/etc/httpd/conf/httpd.conf---------------------------------------------------------------LoadModule proxy_module modules/mod_proxy.soLoadModule proxy_fcgi_module modules/mod_proxy_fcgi.so\n\n创建文件\n\n123456/etc/httpd/conf/extra/php-fpm.conf--------------------------------------------------------------DirectoryIndex index.php index.html&lt;FilesMatch \\.php$&gt;    SetHandler &quot;proxy:unix:/run/php-fpm/php-fpm.sock|fcgi://localhost/&quot;&lt;/FilesMatch&gt;\n\n在 /etc/httpd/conf/httpd.conf 加入配置：\n\n1Include conf/extra/php-fpm.conf\n重启 httpd 服务，端口被占用就把该进程杀掉\n\n测试 PHP 可用性，在 apache 文档根目录（即 /srv/http/ 或 ~public_html ）中写入：\n\n123test.php-------------------------------------------------------------&lt;?php phpinfo(); ?&gt;\n访问 http://localhost/test.php 或者 http://localhost/~myname/test.php 即可看到有关PHP的详细信息\n访问 http://localhost/phpmyadmin/ 使用 phpMyAdmin\n\n懒人桌面启动器：\n\n\n图标是内置的，也可以找一张丢在 /opt\n\n123456789101112131415161718phpmyadmin.desktop------------------------------------------------------------[Desktop Entry]Name=phpMyAdminComment=MySQLClientComment[zh_CN]=MySQL客户端#Keywords=Exec=chromium localhost/phpmyadmin %u#TryExec=Terminal=falseIcon=phpmyadminType=ApplicationCategories=Development;SQLClient;#MimeType=StartupNotify=true#StartupWMClass=#OnlyShowIn=Actions=new-window;\nSSL/TLS支持\n\n先刨坑儿\n\n更多细节参见 https://wiki.archlinux.org/index.php/PhpMyAdmin\n","plink":"https://user-hrsat.github.io/2020/03/07/phpMyAdmin/"},{"title":"FYD","date":"2019-11-10T11:21:20.000Z","date_formatted":{"ll":"2019年11月10日","L":"2019/11/10","MM-DD":"11-10"},"updated":"2020-06-19T14:00:26.000Z","content":"面向小黄鸭(Facing the little yellow duck)\n\n引用小黄鸭调试法.NICE\n\n\n\n可怜的小黄鸭\n\n","plink":"https://user-hrsat.github.io/2019/11/10/fack/"},{"title":"Log","date":"2019-10-14T08:16:42.000Z","date_formatted":{"ll":"2019年10月14日","L":"2019/10/14","MM-DD":"10-14"},"updated":"2020-08-24T16:32:30.000Z","content":"","plink":"https://user-hrsat.github.io/2019/10/14/log/"},{"title":"Blender","date":"2020-02-08T16:50:07.000Z","date_formatted":{"ll":"2020年2月9日","L":"2020/02/09","MM-DD":"02-09"},"updated":"2023-03-25T08:50:14.359Z","content":"Blender\n\n先占坑，Blender知识更新\n\n","plink":"https://user-hrsat.github.io/Blender/"}]